<!-- What is interceptor?
How to write an interceptor?
How to handle interceptor events?
Explain with syntax/example -->

# Interceptors

* Interceptors are one of the built-in tools for specifically handling HTTP requests at a global application level. Often we want to enforce or apply behavior when receiving or sending HTTP requests within our application. Interceptors are a unique type of Angular Service that we can implement. Interceptors allow us to intercept incoming or outgoing HTTP requests using the HttpClient. By intercepting the HTTP request, we can modify or change the value of the request.
* The Angular HTTP interceptors sit between our application and the backend. When the application makes a request, the interceptor catches the request before it is sent to the backend. By Intercepting requests, we will get access to request headers and the body. This enables us to transform the request before sending it to the Server. 
* When the response arrives from the back end the Interceptors can transform it before passing it to our application.
* One of the main benefits of the Http Interceptors is to add the Authorization Header to every request. We could do this manually, but that is a lot of work and error-prone. Another benefit is to catch the errors generated by the request and log them.

# Why do we use interceptors?

Interceptors can be really useful for features like caching and logging. Interceptors are a way to do some work for every single HTTP request or response.
* Add a token or some custom HTTP header for all outgoing HTTP requests
* Catch HTTP responses to do some custom formatting (i.e. convert CSV to JSON) before handing the data over to your service/component
* Log all HTTP activity in the console
* Handle HTTP request by its status code and do common error handle here to manage all HTTP errors.

# How to write an interceptor?
* To create an Interceptor, we need to implement the HttpInterceptor interface from @angular/common/http package. Every time our application makes an HTTP request using the HttpClient service, the Interceptor calls the intercept() method.
* When the intercept() method is called Angular passes a reference to the httpRequest object. With this request, we can inspect it and modify it as necessary. Once our logic is complete, we call next.handle and return the updated request onto the application.
* Once our Interceptor is created, we need to register it as a multi-provider since there can be multiple interceptors running within an application. Important note, you must register the provider to the app.module for it to properly apply to all application HTTP requests. Interceptors will only intercept requests that are made using the HttpClient service.

```javascript 
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { RouterModule, Routes } from '@angular/router';

import { MyInterceptor } from './my.interceptor';
import { AppComponent } from './app.component';

@NgModule({
  imports: [BrowserModule, HttpClientModule],
  declarations: [AppComponent],
  bootstrap: [AppComponent],
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: MyInterceptor, multi: true }
  ]
})
export class AppModule { }
```
To implement an interceptor, you’ll want to create a class that’s injectable and that implements HttpInterceptor. The intercept method takes two arguments, req and next, and returns an observable of type HttpEvent.
* req is the request object itself and is of type HTTP Request.
* next is the HTTP handler, of type HTTP Handler. The handler has a handle method that returns our desired HttpEvent observable.
First, create a service that implements HttpInterceptor:
```javascript
import { HttpInterceptor} from '@angular/common/http';
import { Injectable } from '@angular/core';
 
@Injectable()
export class TokenInterceptorService implements HttpInterceptor {
   intercept(req: HttpRequest<any>, next: HttpHandler):   Observable<HttpEvent<any>> {
       // All HTTP requests are going to go through this method
   }
}
```

The three different Interceptor implementations:
* Handling HTTP Headers
* HTTP Response Formatting
* HTTP Error Handling

# How to handle interceptor events?

* Most HttpClient methods return observables of HttpResponse<any>. The HttpResponse class itself is actually an event, whose type is HttpEventType.Response. A single HTTP request can, however, generate multiple events of other types, including upload and download progress events. The methods HttpInterceptor.intercept() and HttpHandler.handle() return observables of HttpEvent<any>.
* Many interceptors are only concerned with the outgoing request and return the event stream from next.handle() without modifying it. Some interceptors, however, need to examine and modify the response from next.handle(); these operations can see all of these events in the stream.
* Although interceptors are capable of modifying requests and responses, the HttpRequest and HttpResponse instance properties are readonly, rendering them largely immutable. They are immutable for a good reason: an app might retry a request several times before it succeeds, which means that the interceptor chain can re-process the same request multiple times. 
* If an interceptor could modify the original request object, the re-tried operation would start from the modified request rather than the original. Immutability ensures that interceptors see the same request for each try.

# Interface Usecases:

### 1.Looking for Unauthorised Responses
* When tokens expire we will generally get a 401 Unauthorised response back from the server.This gives us an indication that we need the user to log in again to get a new token.
* We need to set up the interceptor to handle responses. The intercept method returns an observable which means we can capture the success and error channels for a response and operate on them however we like.
```javascript
@Injectable()
export class JwtInterceptor implements HttpInterceptor {
  constructor(public auth: AuthService) {}
  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    
    return next.handle(request).do((event: HttpEvent<any>) => {
      if (event instanceof HttpResponse) {
        // do stuff with response if you want
      }
    }, (err: any) => {
      if (err instanceof HttpErrorResponse) {
        if (err.status === 401) {
          // redirect to the login route
          // or show a modal
        }
      }
    });
  }
}
```
```javascript
// auth.service.ts
 
import { HttpRequest } from '@angular/common/http';
 
@Injectable()
export class AuthService {
cachedRequests: Array<HttpRequest<any>> = [];
public collectFailedRequest(request): void {
    this.cachedRequests.push(request);
  }
public retryFailedRequests(): void {
    // retry the requests. this method can
    // be called after the token is refreshed
  }
}
```

### 2. Manage Authentication
First on the list is authentication! It is just so fundamental for many applications that we have a proper authentication system in place. This is one of the most common use cases for interceptors and for a good reason. It fits right in!
There are several things connected to authentication we can do:
* Add bearer token
* Refresh Token
* Redirect to the login page

### 3. Set Headers
We can do a lot by manipulating headers. Some things are:
* Authentication/authorization
* Caching behaviour; for example, If-Modified-Since
* XSRF protection
```javascript 
const modified = req.clone({ 
  setHeaders: { "X-Man": "Wolverine" } 
});
return next.handle(modified);
```

### 4. Converting response
When the API returns a format we do not agree with, we can use an interceptor to format it the way we like it.
This could be converting from XML to JSON or like in this example property names from PascalCase to camelCase.
If the back-end doesn’t care about JSON/JS conventions we can use an interceptor to rename all the property names to camelCase.
```javascript
return next.handle(req).pipe(
  map((event: HttpEvent<any>) => {
    if (event instanceof HttpResponse) {
      let camelCaseObject = mapKeys(event.body, (v, k) => camelCase(k));
      const modEvent = event.clone({ body: camelCaseObject });
      
      return modEvent;
    }
  })
);
```
### 5. Using interceptors to request multiple values
* The HttpClient.get() method normally returns an observable that emits a single value, either the data or an error. An interceptor can change this to an observable that emits multiple values.
* The following revised version of the CachingInterceptor optionally returns an observable that immediately emits the cached response, sends the request on to the package search API, and emits again later with the updated search results.

```javascript
// cache-then-refresh
if (req.headers.get('x-refresh')) {
  const results$ = sendRequest(req, next, this.cache);
  return cachedResponse ?
    results$.pipe( startWith(cachedResponse) ) :
    results$;
}
// cache-or-fetch
return cachedResponse ?
  of(cachedResponse) : sendRequest(req, next, this.cache);
  ```
* The revised CachingInterceptor sets up a server request whether there's a cached value or not, using the same sendRequest() method described above. The results$ observable makes the request when subscribed.
* If there's no cached value, the interceptor returns results$.
* If there is a cached value, the code pipes the cached response onto results$, producing a recomposed observable that emits twice, the cached response first (and immediately), followed later by the response from the server. Subscribers see a sequence of two responses.
  
# Conclusion
Hence, we learned about how to handle the HTTP request and response using Angular interceptors. 
  
# References :
  https://angular.io/api/common/http/HttpInterceptor
  
# Thank You!
